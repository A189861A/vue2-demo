# Vue中的watch与computed区别理解
- 计算属性computed :
    1.计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值
    2.支持缓存
    3.不支持异步，当computed内有异步操作时无效，无法监听数据的变化

- 侦听属性watch：
    1.支持缓存，数据变，直接会触发相应的操作；
    2.watch支持异步
    3.deep: 深度监听
    4.immediate: 组件加载立即触发回调函数执行
    5.监听数据必须是data中声明过或者父组件传递过来的props中的数据
    6.注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异, 只有以响应式的方式触发 才会被监听到

# 组件
    组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。
    仅有的例外是像 el 这样根实例特有的选项。
- 名称规范：
    1. 使用kebab-case命名法(俗称短横线命名法，例如my-test 和my-search)
    2. 使用PascalCase命名法(俗称帕斯卡命名法或大驼峰命名法，例如MyTest和MySearch)  ps:可以转化为短横线名称进行使用
- 分类
    - 按组件注册方式分类
    1.全局组件: 可以在全局任何一个组件内使用
    2.局部组件: 只能在当前注册的范围内使用

    - 按组件有无自己的状态分类
    1. 函数式（无状态）组件
    2. 普通（有状态）组件
    当一个组件是一个函数式组件的时候，它没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法。实际上，它只是一个接受一些 prop 的函数，所以 渲染开销 也低很多。

    # vue实例方法
    - vm.$set
    - vm.$delete
    - vm.$watch

    - vm.$on
    - vm.$emit
    - vm.$once
    - vm.$off

    - vm.$mount
    - vm.$destory
    - vm.$nextTick