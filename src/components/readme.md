# Vue中的watch与computed区别理解
- 计算属性computed :
    1.计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值
    2.支持缓存
    3.不支持异步，当computed内有异步操作时无效，无法监听数据的变化

- 侦听属性watch：
    1.支持缓存，数据变，直接会触发相应的操作；
    2.watch支持异步
    3.deep: 深度监听
    4.immediate: 组件加载立即触发回调函数执行
    5.监听数据必须是data中声明过或者父组件传递过来的props中的数据
    6.注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异, 只有以响应式的方式触发 才会被监听到

# 组件
    组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。
    仅有的例外是像 el 这样根实例特有的选项。
- 名称规范：
    1. 使用kebab-case命名法(俗称短横线命名法，例如my-test 和my-search)
    2. 使用PascalCase命名法(俗称帕斯卡命名法或大驼峰命名法，例如MyTest和MySearch)  ps:可以转化为短横线名称进行使用
- 分类
    - 按组件注册方式分类
    1.全局组件: 可以在全局任何一个组件内使用
    2.局部组件: 只能在当前注册的范围内使用

    - 按组件有无自己的状态分类
    1. 函数式（无状态）组件: 是一个不持有状态data、实例this和生命周期的组件。
    2. 普通（有状态）组件
    当一个组件是一个函数式组件的时候，它没有管理任何状态，也没有监听任何传递给它的状态，也没有生命周期方法。实际上，它只是一个接受一些 prop 的函数，所以 渲染开销 也低很多。

    # vue实例方法
    - vm.$set       通过使用vm.$set这个方法可以使得vue探测到新增属性。
    - vm.$delete    通过这个方法删除属性，可以探测到。
    - vm.$watch     观察实例中一个表达式或者一个函数计算结果的变化。

    - vm.$on        监听vue实例里面的自定义事件，这些事件都是通过vm.$emit触发的
    - vm.$emit      通过触发当前实例上的事件，其中的附加的参数都会传给到监听器进行函数回调。
    - vm.$once      监听一个自定义的事件，但是只能触发一次，一旦触发了，监听器就会被溢出。
    - vm.$off       移除一个自定义的监听器。

    - vm.$mount     如果实例在没有收到el选项的时候，就会处于“没有挂载”的状态，因为没有和它关联的DOM元素。可以使用这个mount方法进行手动挂载。
    - vm.$destory   完全摧毁一个实例，清除和其他实例的连接，并且解除全部指令以及事件监听器。
    - vm.$nextTick  实例方法中的回调函数延迟到DOM更新后才能执行

    # vue实例属性
    - vm.$attrs         包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。
    - vm.$listeners     包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器
    - vm.$root          当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。
    - vm.$children      当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。
    - vm.$slots         用来访问被插槽分发的内容;插槽不是响应性的
    - vm.$scopedSlots   

#   vue 2.X 组件间通信方式

#   插槽
- 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。


# Attributes 继承
- “透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。
- 当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上
